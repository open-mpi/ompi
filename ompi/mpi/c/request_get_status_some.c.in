/*
 * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
 *                         University Research and Technology
 *                         Corporation.  All rights reserved.
 * Copyright (c) 2004-2021 The University of Tennessee and The University
 *                         of Tennessee Research Foundation.  All rights
 *                         reserved.
 * Copyright (c) 2004-2008 High Performance Computing Center Stuttgart,
 *                         University of Stuttgart.  All rights reserved.
 * Copyright (c) 2004-2005 The Regents of the University of California.
 *                         All rights reserved.
 * Copyright (c) 2006-2010 Cisco Systems, Inc.  All rights reserved.
 * Copyright (c) 2015      Research Organization for Information Science
 *                         and Technology (RIST). All rights reserved.
 * Copyright (c) 2024      Triad National Security, LLC. All rights
 *                         reserved.
 * Copyright (c) 2025      Advanced Micro Devices, Inc. All rights reserved
 *
 * $COPYRIGHT$
 *
 * Additional copyrights may follow
 *
 * $HEADER$
 */
#include "ompi_config.h"
#include <stdio.h>

#include "ompi/mpi/c/bindings.h"
#include "ompi/runtime/params.h"
#include "ompi/communicator/communicator.h"
#include "ompi/errhandler/errhandler.h"
#include "ompi/request/request.h"
#include "ompi/request/grequest.h"
#include "ompi/memchecker.h"

/* Non blocking status retrieval. Upon completion, the request(s) will
 * not be freed (unlike the test function). A subsequent call to test, wait
 * or free should be executed on the request(s).
 */
PROTOTYPE ERROR_CLASS request_get_status_some(INT incount, REQUEST_CONST requests:incount, INT_OUT outcount,
                                              INT_OUT indices,  STATUS_OUT statuses:incount)
{

    MEMCHECKER(
       int j;
       for (j = 0; j< incount;  j++) {
           memchecker_request(&requests[j]);
       }
    );

    if( MPI_PARAM_CHECK ) {
        int rc = MPI_SUCCESS;

        OMPI_ERR_INIT_FINALIZE(FUNC_NAME);
        if (NULL == requests) {
            rc = MPI_ERR_REQUEST;
        } else {
            /* Need to cast the const away, since the request argument for most
            ** MPI functions invoking this functionality does not have the const
            ** argument
            */
            if(!ompi_request_check_same_instance((MPI_Request *)requests, incount) ) {
                rc = MPI_ERR_REQUEST;
            }
        }
        if ((NULL == outcount) || (incount < 0) || (NULL == indices) ) {
            rc = MPI_ERR_ARG;
        }
        OMPI_ERRHANDLER_NOHANDLE_CHECK(rc, rc, FUNC_NAME);
    }

    if (OPAL_UNLIKELY(0 == incount)) {
        *outcount = 0;
        return MPI_SUCCESS;
    }

    bool all_inactive;

#if OPAL_ENABLE_PROGRESS_THREADS == 0
    bool do_it_once = true;
 recheck_request_status:
#endif

    opal_atomic_mb();
    int i;
    int indx = 0;
    all_inactive = true;
    for (i = 0; i < incount; i++) {
        if ( (requests[i] == MPI_REQUEST_NULL) || (requests[i]->req_state == OMPI_REQUEST_INACTIVE) ) {
            continue;
        }
        all_inactive = false;
        if (requests[i]->req_complete ) {
            indices[indx] = i;
            /* If this is a generalized request, we *always* have to call
               the query function to get the status (MPI-2:8.2), even if
               the user passed STATUS_IGNORE. */
            if (OMPI_REQUEST_GEN == requests[i]->req_type) {
                ompi_grequest_invoke_query(requests[i], &requests[i]->req_status);
            }
            if (MPI_STATUS_IGNORE != statuses) {
                OMPI_COPY_STATUS(&statuses[indx], requests[i]->req_status, false);
            }
            indx++;
        }
    }

    if (all_inactive) {
        *outcount = MPI_UNDEFINED;
        return MPI_SUCCESS;
    }

    if (0 < indx) {
        *outcount = indx;
        return MPI_SUCCESS;
    }

#if OPAL_ENABLE_PROGRESS_THREADS == 0
    if(do_it_once) {
        /* If we run the opal_progress then check the status of the
           request before leaving. We will call the opal_progress only
           once per call. */
        opal_progress();
        do_it_once = false;
        goto recheck_request_status;
    }
#endif

    *outcount = 0;
    return MPI_SUCCESS;
}
