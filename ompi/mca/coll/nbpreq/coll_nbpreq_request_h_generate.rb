#!/usr/bin/env ruby
#
# Copyright (c) 2017      FUJITSU LIMITED.  All rights reserved.
# $COPYRIGHT$
#
# Additional copyrights may follow
#
# $HEADER$
#
# Script generates contents of the ompi/mca/coll/nbpreq/coll_nbpreq_request.h
#

# path of the ompi/mca/coll/base/coll_base_functions.h file
coll_base_functions_h_path =
  File.dirname($PROGRAM_NAME) + '/../base/coll_base_functions.h'

# parse '#define XXXX_BASE_ARGS ...' lines
# in the ompi/mca/coll/base/coll_base_functions.h file

funcs = [ ]

File.open(coll_base_functions_h_path) do |file|

  file.each_line do |args_def|

    if args_def !~ /^#define ([A-Z_]+)_BASE_ARGS +(.+)$/
      next
    end

    func = { }
    func[:name] = $1.downcase #=> 'bcast'
    func[:args] = $2.split(/, /).collect do |arg|
      arg =~ /[ \*]([a-z_]+)(?:\[\])?$/
      { spec: arg, name: $1 } #=> { spec: 'void *buffer', name: 'buffer' }
    end
    funcs.push(func)

  end

end

# output definition of union mca_coll_nbpreq_func_args_t if -r option is given

if ARGV.size > 0 && ARGV[0] == '-r'

  puts('union mca_coll_nbpreq_func_args_t {')
  funcs.each do |func|
    puts "    struct {"
    func[:args].each do |arg|
      # replace trailing '[]' with leading '*'
      spec = arg[:spec].gsub(/(\w+)(?:\[\])$/, '*\1')
      puts "        #{spec};"
    end
    puts "    } #{func[:name]};"
  end
  puts('};')

  exit

end

# output the header

puts <<-EOS.delete("\t")
	// This file is generated by #{File.basename($PROGRAM_NAME)}
	// and included from coll_nbpreq_request.c
	EOS

# output definition of a save_func_args_xxxx function for each collective type

funcs.each do |func|

  func_name = func[:name]
  max_arg_name_len = func[:args].collect { |arg| arg[:name].size } .max

  puts <<-EOS.delete("\t")
	
	static inline void
	save_func_args_#{func_name}(mca_coll_nbpreq_request_t *req,
	#{' '*(func_name.size+16)}#{func_name.upcase}_BASE_ARGS)
	{
	    mca_coll_nbpreq_func_args_t *args = &req->func_args;
	EOS

  # lines to save arguments
  func[:args].each do |arg|
    space = ' ' * (max_arg_name_len - arg[:name].size)
    puts <<-EOS.delete("\t")
	    args->#{func_name}.#{arg[:name]}#{space} = #{arg[:name]};
	EOS
  end

  puts <<-EOS.delete("\t")
	}
	EOS
end

# output definition of a call_nb_func_xxxx function for each collective type

funcs.each do |func|

  func_name = func[:name]
  func_name_us =
    (func_name == 'reducescatter')      ? 'reduce_scatter' :
    (func_name == 'reducescatterblock') ? 'reduce_scatter_block' :
    func_name

  puts <<-EOS.delete("\t")
	
	static inline int
	call_nb_func_#{func_name}(mca_coll_nbpreq_request_t *req)
	{
	    return req->comm->c_coll->coll_i#{func_name_us}(
	EOS

  func[:args].each do |arg|
    puts <<-EOS.delete("\t")
	               req->func_args.#{func_name}.#{arg[:name]},
	EOS
  end

  puts <<-EOS.delete("\t")
	               &req->nb_request,
	               req->comm->c_coll->coll_i#{func_name_us}_module);
	}
	EOS
end

# output definitions of the call_nb_func function

puts <<-EOS.delete("\t")
	
	static inline int
	call_nb_func(mca_coll_nbpreq_request_t *req)
	{
	    switch (req->coll_type) {
	EOS

funcs.each do |func|
  puts <<-EOS.delete("\t")
	    case #{func[:name].upcase}:
	        return call_nb_func_#{func[:name]}(req);
	EOS
end

puts <<-EOS.delete("\t")
	    default:
	        return OMPI_ERROR;
	    }
	}
	EOS
