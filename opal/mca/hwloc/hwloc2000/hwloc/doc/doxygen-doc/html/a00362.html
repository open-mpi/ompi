<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hardware Locality (hwloc): Frequently Asked Questions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hardware Locality (hwloc)
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Frequently Asked Questions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<div class="section" id="faq1">
 </p>
<h1><a class="anchor" id="faq1"></a>
Concepts</h1>
<h2><a class="anchor" id="faq_why"></a>
I only need binding, why should I use hwloc ?</h2>
<p>hwloc is its portable API that works on a variety of operating systems. It supports binding of threads, processes and memory buffers (see <a class="el" href="a00190.html">CPU binding</a> and <a class="el" href="a00191.html">Memory binding</a>). Even if some features are not supported on some systems, using hwloc is much easier than reimplementing your own portability layer.</p>
<p>Moreover, hwloc provides knowledge of cores and hardware threads. It offers easy ways to bind tasks to individual hardware threads, or to entire multithreaded cores, etc. See <a class="el" href="a00362.html#faq_smt">How may I ignore symmetric multithreading, hyper-threading, etc. in hwloc?</a>. Most alternative software for binding do not even know whether each core is single-threaded, multithreaded or hyper-threaded. They would bind to individual threads without any way to know whether multiple tasks are in the same physical core.</p>
<p>However, using hwloc comes with an overhead since a topology must be loaded before gathering information and binding tasks or memory. Fortunately this overhead may be significantly reduced by filtering non-interesting information out of the topology. For instance the following code builds a topology that only contains Cores, hardware threads (PUs, cannot be filtered-out), and NUMA nodes (cannot be filtered-out).</p>
<pre class="fragment">hwloc_topology_t topology;
hwloc_topology_init(&amp;topology);
hwloc_topology_set_all_types_filter(topology, HWLOC_TYPE_FILTER_KEEP_NONE);
hwloc_topology_set_type_filter(topology, HWLOC_OBJ_CORE, HWLOC_TYPE_FILTER_KEEP_ALL);
hwloc_topology_load(topology);
</pre><p>However, one should remember that filtering such objects out removes locality information from the hwloc tree. For instance, we do not know anymore which PU is close to which NUMA node. This would be useful to applications that explicitly want to place specific memory buffers close to specific tasks. Those applications just need to tell hwloc to keep Group objects that bring structure information: </p><pre class="fragment">hwloc_topology_set_type_filter(topology, HWLOC_OBJ_GROUP, HWLOC_TYPE_FILTER_KEEP_STRUCTURE);
</pre><p>Note that the default configuration is to keep all objects enabled, except I/Os and instruction caches.</p>
<h2><a class="anchor" id="faq_indexes"></a>
Should I use logical or physical/OS indexes? and how?</h2>
<p>One of the original reasons why hwloc was created is that <b>physical/OS indexes</b> (<code>obj-&gt;os_index</code>) are often crazy and unpredictable: logical processors numbers are usually non-contiguous (processors 0 and 1 are not physically close), they vary from one machine to another, and may even change after a BIOS or system update. This numbers make task placement hardly portable. Moreover some objects have no physical/OS numbers (caches), and some objects have non-unique numbers (core numbers are only unique within a socket). Physical/OS indexes are only guaranteed to exist and be unique for PU and NUMA nodes.</p>
<p>hwloc therefore introduces <b>logical indexes</b> (<code>obj-&gt;logical_index</code>) which are portable, contiguous and logically ordered (based on the resource organization in the locality tree). In general, one should only use logical indexes and just let hwloc do the internal conversion when really needed (when talking to the OS and hardware).</p>
<p>hwloc developers recommends that users do not use physical/OS indexes unless they really know what they are doing. The main reason for still using physical/OS indexes is when interacting with non-hwloc tools such as numactl or taskset, or when reading hardware information from raw sources such as /proc/cpuinfo.</p>
<p>lstopo options <code>-l</code> and <code>-p</code> may be used to switch between logical indexes (prefixed with <code>L#</code>) and physical/OS indexes (<code>P#</code>). Converting one into the other may also be achieved with hwloc-calc which may manipulate either logical or physical indexes as input or output. See also <a class="el" href="a00350.html#cli_hwloc_calc">hwloc-calc</a>.</p>
<pre class="fragment"># Convert PU with physical number 3 into logical number
$ hwloc-calc -I pu --physical-input --logical-output pu:3
5

# Convert a set of NUMA nodes from logical to physical
# (beware that the output order may not match the input order)
$ hwloc-calc -I numa --logical-input --physical-output numa:2-3 numa:7
0,2,5
</pre><h2><a class="anchor" id="faq_structural"></a>
hwloc is only a structural model, it ignores performance models, memory bandwidth, etc.?</h2>
<p>hwloc is indeed designed to provide applications with a structural model of the platform. This is an orthogonal approach to describing the machine with performance models, for instance using memory bandwidth or latencies measured by benchmarks. We believe that both approaches are important for helping application make the most of the hardware.</p>
<p>For instance, on a dual-processor host with four cores each, hwloc clearly shows which four cores are together. Latencies between all pairs of cores of the same processor are likely identical, and also likely lower than the latency between cores of different processors. However, the structural model cannot guarantee such implementation details. On the other side, performance models would reveal such details without always clearly identifying which cores are in the same processor.</p>
<p>The focus of hwloc is mainly of the structural modeling side. However, hwloc lets user adds performance information to the topology through distances (see <a class="el" href="a00208.html">Retrieve distances between objects</a> and <a class="el" href="a00210.html">Add or remove distances between objects</a>) or even custom annotations (see <a class="el" href="a00362.html#faq_annotate">How do I annotate the topology with private notes?</a>). hwloc may also use such distance information for grouping objects together (see <a class="el" href="a00362.html#faq_onedim">hwloc only has a one-dimensional view of the architecture, it ignores distances?</a> and <a class="el" href="a00362.html#faq_groups">What are these Group objects in my topology?</a>).</p>
<h2><a class="anchor" id="faq_onedim"></a>
hwloc only has a one-dimensional view of the architecture, it ignores distances?</h2>
<p>hwloc places all objects in a tree. Each level is a one-dimensional view of a set of similar objects. All children of the same object (siblings) are assumed to be equally interconnected (same distance between any of them), while the distance between children of different objects (cousins) is supposed to be larger.</p>
<p>Modern machines exhibit complex hardware interconnects, so this tree may miss some information about the actual physical distances between objects. The hwloc topology may therefore be annotated with distance information that may be used to build a more realistic representation (multi-dimensional) of each level. For instance, there can be a distance matrix that representing the latencies between any pair of NUMA nodes if the BIOS and/or operating system reports them.</p>
<p>For more information about the distance API, see <a class="el" href="a00208.html">Retrieve distances between objects</a> and <a class="el" href="a00210.html">Add or remove distances between objects</a>.</p>
<h2><a class="anchor" id="faq_groups"></a>
What are these Group objects in my topology?</h2>
<p>hwloc comes with a set of predefined object types (Core, Package, NUMA node, Caches) that match the vast majority of hardware platforms. The <a class="el" href="a00184.html#ggacd37bb612667dc437d66bfb175a8dc55a5269ef95be72f88465559d35c9b7ad56" title="Group objects. Objects which do not fit in the above but are detected by hwloc and are useful to take...">HWLOC_OBJ_GROUP</a> type was designed for cases where this set is not sufficient. Groups may be used anywhere to add more structure information to the topology, for instance to show that 2 out of 4 NUMA nodes are actually closer than the others. When applicable, the <code>subtype</code> field describes why a Group was actually added (see also <a class="el" href="a00355.html#attributes_normal">Normal attributes</a>).</p>
<p>hwloc currently uses Groups for the following reasons: </p><ul>
<li>
NUMA parents when memory locality does not match any existing object. </li>
<li>
I/O parents when I/O locality does not match any existing object. </li>
<li>
Distance-based groups made of close objects. </li>
<li>
AMD dual-core compute units (<code>subtype</code> is <code>ComputeUnit</code>, in the x86 backend), but these objects are usually merged with the L2 caches. </li>
<li>
Intel x2APIC non-core and non-package levels (in the x86 backend). </li>
<li>
Windows processor groups (unless they contain a single NUMA node, or a single Package, etc.). </li>
<li>
IBM S/390 "Books" on Linux (<code>subtype</code> is <code>Book</code>). </li>
<li>
AIX unknown hierarchy levels. </li>
</ul>
<p>hwloc Groups are only kept if no other object has the same locality information. It means that a Group containing a single child is merged into that child. And a Group is merged into its parent if it is its only child. For instance a Windows processor group containing a single NUMA node would be merged with that NUMA node since it already contains the relevant hierarchy information.</p>
<h2><a class="anchor" id="faq_asymmetric"></a>
What happens if my topology is asymmetric?</h2>
<p>hwloc supports asymmetric topologies even if most platforms are usually symmetric. For example, there could be different types of processors in a single machine, each with different numbers of cores, symmetric multithreading, or levels of caches.</p>
<p>In practice, asymmetric topologies mostly appear when intermediate groups are added for I/O affinity: on a 4-package machine, an I/O bus may be connected to 2 packages. These packages are below an additional Group object, while the other packages are not (see also <a class="el" href="a00362.html#faq_groups">What are these Group objects in my topology?</a>).</p>
<p>To understand how hwloc manages such cases, one should first remember the meaning of levels and cousin objects. All objects of the same type are gathered as horizontal levels with a given depth. They are also connected through the cousin pointers of the <a class="el" href="a00235.html" title="Structure of a topology object. ">hwloc_obj</a> structure. Object attribute (cache depth and type, group depth) are also taken in account when gathering objects as horizontal levels. To be clear: there will be one level for L1i caches, another level for L1d caches, another one for L2, etc.</p>
<p>If the topology is asymmetric (e.g., if a group is missing above some processors), a given horizontal level will still exist if there exist any objects of that type. However, some branches of the overall tree may not have an object located in that horizontal level. Note that this specific hole within one horizontal level does not imply anything for other levels. All objects of the same type are gathered in horizontal levels even if their parents or children have different depths and types.</p>
<p>See the diagram in <a class="el" href="a00349.html">Terms and Definitions</a> for a graphical representation of such topologies.</p>
<p>Moreover, it is important to understand that a same parent object may have children of different types (and therefore, different depths). <b>These children are therefore siblings (because they have the same parent), but they are <em>not</em> cousins (because they do not belong to the same horizontal level).</b></p>
<h2><a class="anchor" id="faq_nosmt"></a>
What happens to my topology if I disable symmetric multithreading, hyper-threading, etc. in the system?</h2>
<p>hwloc creates one PU (processing unit) object per hardware thread. If your machine supports symmetric multithreading, for instance Hyper-Threading, each Core object may contain multiple PU objects: </p><pre class="fragment">$ lstopo -
...
  Core L#0
    PU L#0 (P#0)
    PU L#1 (P#2)
  Core L#1
    PU L#2 (P#1)
    PU L#3 (P#3)
</pre><p>x86 machines usually offer the ability to disable hyper-threading in the BIOS. Or it can be disabled on the Linux kernel command-line at boot time, or later by writing in sysfs virtual files.</p>
<p>If you do so, the hwloc topology structure does not significantly change, but some PU objects will not appear anymore. No level will disappear, you will see the same number of Core objects, but each of them will contain a single PU now. The PU level does not disappear either (remember that hwloc topologies always contain a PU level at the bottom of the topology) even if there is a single PU object per Core parent. </p><pre class="fragment">$ lstopo -
...
  Core L#0
    PU L#0 (P#0)
  Core L#1
    PU L#1 (P#1)
</pre><h2><a class="anchor" id="faq_smt"></a>
How may I ignore symmetric multithreading, hyper-threading, etc. in hwloc?</h2>
<p>First, see <a class="el" href="a00362.html#faq_nosmt">What happens to my topology if I disable symmetric multithreading, hyper-threading, etc. in the system?</a> for more information about multithreading.</p>
<p>If you need to ignore symmetric multithreading in software, you should likely manipulate hwloc Core objects directly: </p><pre class="fragment">/* get the number of cores */
unsigned nbcores = hwloc_get_nbobjs_by_type(topology, HWLOC_OBJ_CORE);
...
/* get the third core below the first package */
hwloc_obj_t package, core;
package = hwloc_get_obj_by_type(topology, HWLOC_OBJ_PACKAGE, 0);
core = hwloc_get_obj_inside_cpuset_by_type(topology, package-&gt;cpuset,
                                           HWLOC_OBJ_CORE, 2);
</pre><p>Whenever you want to bind a process or thread to a core, make sure you singlify its cpuset first, so that the task is actually bound to a single thread within this core (to avoid useless migrations). </p><pre class="fragment">/* bind on the second core */
hwloc_obj_t core = hwloc_get_obj_by_type(topology, HWLOC_OBJ_CORE, 1);
hwloc_cpuset_t set = hwloc_bitmap_dup(core-&gt;cpuset);
hwloc_bitmap_singlify(set);
hwloc_set_cpubind(topology, set, 0);
hwloc_bitmap_free(set);
</pre><p>With hwloc-calc or hwloc-bind command-line tools, you may specify that you only want a single-thread within each core by asking for their first PU object: </p><pre class="fragment">$ hwloc-calc core:4-7
0x0000ff00
$ hwloc-calc core:4-7.pu:0
0x00005500
</pre><p>When binding a process on the command-line, you may either specify the exact thread that you want to use, or ask hwloc-bind to singlify the cpuset before binding </p><pre class="fragment">$ hwloc-bind core:3.pu:0 -- echo "hello from first thread on core #3"
hello from first thread on core #3
...
$ hwloc-bind core:3 --single -- echo "hello from a single thread on core #3"
hello from a single thread on core #3
</pre><p> 
</div><div class="section" id="faq2">
 </p>
<h1><a class="anchor" id="faq2"></a>
Advanced</h1>
<h2><a class="anchor" id="faq_xml"></a>
I do not want hwloc to rediscover my enormous machine topology every time I rerun a process</h2>
<p>Although the topology discovery is not expensive on common machines, its overhead may become significant when multiple processes repeat the discovery on large machines (for instance when starting one process per core in a parallel application). The machine topology usually does not vary much, except if some cores are stopped/restarted or if the administrator restrictions are modified. Thus rediscovering the whole topology again and again may look useless.</p>
<p>For this purpose, hwloc offers XML import/export and shared memory features.</p>
<p>XML lets you save the discovered topology to a file (for instance with the lstopo program) and reload it later by setting the HWLOC_XMLFILE environment variable. The HWLOC_THISSYSTEM environment variable should also be set to 1 to assert that loaded file is really the underlying system.</p>
<p>Loading a XML topology is usually much faster than querying multiple files or calling multiple functions of the operating system. It is also possible to manipulate such XML files with the C programming interface, and the import/export may also be directed to memory buffer (that may for instance be transmitted between applications through a package). See also <a class="el" href="a00356.html">Importing and exporting topologies from/to XML files</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The environment variable HWLOC_THISSYSTEM_ALLOWED_RESOURCES may be used to load a XML topology that contains the entire machine and restrict it to the part that is actually available to the current process (e.g. when Linux Cgroup/Cpuset are used to restrict the set of resources). See <a class="el" href="a00351.html">Environment Variables</a>.</dd></dl>
<p>Shared-memory topologies consist in one process exposing its topology in a shared-memory buffer so that other processes (running on the same machine) may use it directly. This has the advantage of reducing the memory footprint since a single topology is stored in physical memory for multiple processes. However, it requires all processes to map this shared-memory buffer at the same virtual address, which may be difficult in some cases. This API is described in <a class="el" href="a00223.html">Sharing topologies between processes</a>.</p>
<h2><a class="anchor" id="faq_multitopo"></a>
How many topologies may I use in my program?</h2>
<p>hwloc lets you manipulate multiple topologies at the same time. However, these topologies consume memory and system resources (for instance file descriptors) until they are destroyed. It is therefore discouraged to open the same topology multiple times.</p>
<p>Sharing a single topology between threads is easy (see <a class="el" href="a00359.html">Thread Safety</a>) since the vast majority of accesses are read-only.</p>
<p>If multiple topologies of different (but similar) nodes are needed in your program, have a look at <a class="el" href="a00362.html#faq_diff">How to avoid memory waste when manipulating multiple similar topologies?</a>.</p>
<h2><a class="anchor" id="faq_diff"></a>
How to avoid memory waste when manipulating multiple similar topologies?</h2>
<p>hwloc does not share information between topologies. If multiple similar topologies are loaded in memory, for instance the topologies of different identical nodes of a cluster, lots of information will be duplicated.</p>
<p><a class="el" href="a00170_source.html" title="Topology differences. ">hwloc/diff.h</a> (see also <a class="el" href="a00222.html">Topology differences</a>) offers the ability to compute topology differences, apply or unapply them, or export/import to/from XML. However, this feature is limited to basic differences such as attribute changes. It does not support complex modifications such as adding or removing some objects.</p>
<h2><a class="anchor" id="faq_annotate"></a>
How do I annotate the topology with private notes?</h2>
<p>Each hwloc object contains a <code>userdata</code> field that may be used by applications to store private pointers. This field is only valid during the lifetime of these container object and topology. It becomes invalid as soon the topology is destroyed, or as soon as the object disappears, for instance when restricting the topology. The userdata field is not exported/imported to/from XML by default since hwloc does not know what it contains. This behavior may be changed by specifying application-specific callbacks with <code><a class="el" href="a00206.html#ga9d6ff0f7a8dd45be9aa8575ef31978cc" title="Set the application-specific callback for exporting object userdata. ">hwloc_topology_set_userdata_export_callback()</a></code> and <code><a class="el" href="a00206.html#ga5ac6917ea7289955fb1ffda4353af9b0" title="Set the application-specific callback for importing userdata. ">hwloc_topology_set_userdata_import_callback()</a></code>.</p>
<p>Each object may also contain some <em>info</em> attributes (key name and value) that are setup by hwloc during discovery and that may be extended by the user with <code><a class="el" href="a00189.html#gace7654bb8a9002caae1a4b8a59e7452e" title="Add the given info name and value pair to the given object. ">hwloc_obj_add_info()</a></code> (see also <a class="el" href="a00355.html">Object attributes</a>). Contrary to the <code>userdata</code> field which is unique, multiple info attributes may exist for each object, even with the same name. These attributes are always exported to XML. However, only character strings may be used as key names and values.</p>
<p>It is also possible to insert Misc objects with a custom name anywhere as a leaf of the topology (see <a class="el" href="a00354.html">Miscellaneous objects</a>). And Misc objects may have their own userdata and info attributes just like any other object.</p>
<p>The hwloc-annotate command-line tool may be used for adding Misc objects and info attributes.</p>
<p>There is also a topology-specific userdata pointer that can be used to recognize different topologies by storing a custom pointer. It may be manipulated with <code><a class="el" href="a00193.html#ga2cc7b7b155cba58dda203e54f1637b9c" title="Set the topology-specific userdata pointer. ">hwloc_topology_set_userdata()</a></code> and <code><a class="el" href="a00193.html#ga91f992f8d6c4905b2d3c4f43e509c2a3" title="Retrieve the topology-specific userdata pointer. ">hwloc_topology_get_userdata()</a></code>.</p>
<p> 
</div><div class="section" id="faq3">
 </p>
<h1><a class="anchor" id="faq3"></a>
Caveats</h1>
<h2><a class="anchor" id="faq_slow_lstopo"></a>
Why is hwloc slow?</h2>
<p>Building a hwloc topology on a large machine may be slow because the discovery of hundreds of hardware cores or threads takes time (especially when reading thousands of sysfs files on Linux). Ignoring some objects (for instance caches) that aren't useful to the current application may improve this overhead (see <a class="el" href="a00362.html#faq_why">I only need binding, why should I use hwloc ?</a>). One should also consider using XML (see <a class="el" href="a00362.html#faq_xml">I do not want hwloc to rediscover my enormous machine topology every time I rerun a process</a>) to work around such issues.</p>
<p>Additionally, lstopo enables most hwloc objects and discovery flags by default so that the output topology is as precise as possible (while hwloc disables many of them by default). This includes I/O device discovery through PCI libraries as well as external libraries such as NVML. To speed up lstopo, you may disable such features with command-line options such as <code>--no-io</code>.</p>
<p>When NVIDIA GPU probing is enabled with CUDA or NVML, one should make sure that the <em>Persistent</em> mode is enabled (with <code>nvidia-smi -pm 1</code>) to avoid significant GPU initialization overhead.</p>
<p>When AMD GPU discovery is enabled with OpenCL and hwloc is used remotely over ssh, some spurious round-trips on the network may significantly increase the discovery time. Forcing the <code>DISPLAY</code> environment variable to the remote X server display (usually <code>:0</code>) instead of only setting the <code>COMPUTE</code> variable may avoid this.</p>
<p>Also remember that these components may be disabled at build-time with configure flags such as <code>--disable-opencl</code>, <code>--disable-cuda</code> or <code>--disable-nvml</code>, and at runtime with the environment variable <code>HWLOC_COMPONENTS=-opencl,cuda,nvml</code>.</p>
<h2><a class="anchor" id="faq_privileged"></a>
Does hwloc require privileged access?</h2>
<p>hwloc discovers the topology by querying the operating system. Some minor features may require privileged access to the operation system. For instance memory module and PCI link speed discovery on Linux is reserved to root, and the entire PCI discovery on Solaris and BSDs requires access to some special files that are usually restricted to root (/dev/pci* or /devices/pci*).</p>
<p>To workaround this limitation, it is recommended to export the topology as a XML file generated by the administrator (with the lstopo program) and make it available to all users (see <a class="el" href="a00356.html">Importing and exporting topologies from/to XML files</a>). It will offer all discovery information to any application without requiring any privileged access anymore. Only the necessary hardware characteristics will be exported, no sensitive information will be disclosed through this XML export.</p>
<p>This XML-based model also has the advantage of speeding up the discovery because reading a XML topology is usually much faster than querying the operating system again.</p>
<p>The utility <code>hwloc-dump-hwdata</code> is also involved in gathering privileged information at boot time and making it available to non-privileged users (note that this may require a specific SELinux MLS policy module). However, it only applies to Intel Knights Landing Xeon Phi for now (see <a class="el" href="a00362.html#faq_knl_dump">Why do I need hwloc-dump-hwdata for memory on Intel Knights Landing Xeon Phi?</a>). See also <code>HWLOC_DUMPED_HWDATA_DIR</code> in <a class="el" href="a00351.html">Environment Variables</a> for details about the location of dumped files.</p>
<h2><a class="anchor" id="faq_os_error"></a>
What should I do when hwloc reports "operating system" warnings?</h2>
<p>When the operating system reports invalid locality information (because of either software or hardware bugs), hwloc may fail to insert some objects in the topology because they cannot fit in the already built tree of resources. If so, hwloc will report a warning like the following. The object causing this error is ignored, the discovery continues but the resulting topology will miss some objects and may be asymmetric (see also <a class="el" href="a00362.html#faq_asymmetric">What happens if my topology is asymmetric?</a>).</p>
<pre class="fragment">****************************************************************************
* hwloc has encountered what looks like an error from the operating system.
*
* L3 (cpuset 0x000003f0) intersects with NUMANode (P#0 cpuset 0x0000003f) without inclusion!
* Error occurred in topology.c line 940
*
* Please report this error message to the hwloc user's mailing list,
* along with the files generated by the hwloc-gather-topology script.
****************************************************************************
</pre><p>These errors are common on large AMD platforms because of BIOS and/or Linux kernel bugs causing invalid L3 cache information. In the above example, the hardware reports a L3 cache that is shared by 2 cores in the first NUMA node and 4 cores in the second NUMA node. That's wrong, it should actually be shared by all 6 cores in a single NUMA node. The resulting topology will miss some L3 caches.</p>
<p>If your application does not care about cache sharing, or if you do not plan to request cache-aware binding in your process launcher, you may likely ignore this error (and hide it by setting HWLOC_HIDE_ERRORS=1 in your environment).</p>
<p>Some platforms report similar warnings about conflicting Packages and NUMANodes.</p>
<p>On x86 hosts, passing <code>HWLOC_COMPONENTS=x86</code> in the environment may workaround some of these issues by switching to a different way to discover the topology.</p>
<p>Upgrading the BIOS and/or the operating system may help. Otherwise, as explained in the message, reporting this issue to the hwloc developers (by sending the tarball that is generated by the hwloc-gather-topology script on this platform) is a good way to make sure that this is a software (operating system) or hardware bug (BIOS, etc).</p>
<p>See also <a class="el" href="index.html#bugs">Questions and Bugs</a>. Opening an issue on GitHub automatically displays hints on what information you should provide when reporting such bugs.</p>
<h2><a class="anchor" id="faq_valgrind"></a>
Why does Valgrind complain about hwloc memory leaks?</h2>
<p>If you are debugging your application with Valgrind, you want to avoid memory leak reports that are caused by hwloc and not by your program.</p>
<p>hwloc itself is often checked with Valgrind to make sure it does not leak memory. However, some global variables in hwloc dependencies are never freed. For instance libz allocates its global state once at startup and never frees it so that it may be reused later. Some libxml2 global state is also never freed because hwloc does not know whether it can safely ask libxml2 to free it (the application may also be using libxml2 outside of hwloc).</p>
<p>These unfreed variables cause leak reports in Valgrind. hwloc installs a Valgrind <em>suppressions</em> file to hide them. You should pass the following command-line option to Valgrind to use it: </p><pre class="fragment">  --suppressions=/path/to/hwloc-valgrind.supp
</pre><h2><a class="anchor" id="faq_upgrade"></a>
How do I handle ABI breaks and API upgrades?</h2>
<p>The hwloc interface is extended with every new major release. Any application using the hwloc API should be prepared to check at compile-time whether some features are available in the currently installed hwloc distribution.</p>
<p>For instance, to check whether the hwloc version is at least 2.0, you should use: </p><pre class="fragment">#include &lt;hwloc.h&gt;
#if HWLOC_API_VERSION &gt;= 0x00020000
...
#endif
</pre><p>To check for the API of release X.Y.Z at build time, you may compare <a class="el" href="a00182.html#ga8f4dfb8eef138af55dd1a0fa802e5476" title="Indicate at build time which hwloc API version is being used. ">HWLOC_API_VERSION</a> with <code>(X&gt;&gt;16)+(Y&gt;&gt;8)+Z</code>.</p>
<p>For supporting older releases that do not have <code>HWLOC_OBJ_NUMANODE</code> and <code>HWLOC_OBJ_PACKAGE</code> yet, you may use:</p>
<pre class="fragment">#include &lt;hwloc.h&gt;
#if HWLOC_API_VERSION &lt; 0x00010b00
#define HWLOC_OBJ_NUMANODE HWLOC_OBJ_NODE
#define HWLOC_OBJ_PACKAGE HWLOC_OBJ_SOCKET
#endif
</pre><p>The hwloc interface was deeply modified in release 2.0 to fix several issues of the 1.x interface (see <a class="el" href="a00363.html">Upgrading to the hwloc 2.0 API</a> and the NEWS file in the source directory for details). The ABI was broken, which means <b>applications must be recompiled against the new 2.0 interface</b>.</p>
<p>To check that you are not mixing old/recent headers with a recent/old runtime library, check the major revision number in the API version: </p><pre class="fragment">#include &lt;hwloc.h&gt;
  unsigned version = hwloc_get_api_version();
  if ((version &gt;&gt; 16) != (HWLOC_API_VERSION &gt;&gt; 16)) {
    fprintf(stderr,
           "%s compiled for hwloc API 0x%x but running on library API 0x%x.\n"
           "You may need to point LD_LIBRARY_PATH to the right hwloc library.\n"
           "Aborting since the new ABI is not backward compatible.\n",
           callname, HWLOC_API_VERSION, version);
    exit(EXIT_FAILURE);
  }
</pre><p> To specifically detect v2.0 issues: </p><pre class="fragment">#include &lt;hwloc.h&gt;
#if HWLOC_API_VERSION &gt;= 0x00020000
  /* headers are recent */
  if (hwloc_get_api_version() &lt; 0x20000)
    ... error out, the hwloc runtime library is older than 2.0 ...
#else
  /* headers are pre-2.0 */
  if (hwloc_get_api_version() &gt;= 0x20000)
    ... error out, the hwloc runtime library is more recent than 2.0 ...
#endif
</pre><p>You should not try to remain compatible with very old releases such as 1.1.x or earlier because <code><a class="el" href="a00182.html#ga8f4dfb8eef138af55dd1a0fa802e5476" title="Indicate at build time which hwloc API version is being used. ">HWLOC_API_VERSION</a></code> was added in 1.0.0 and <code><a class="el" href="a00182.html#ga9c0b50c98add1adf57ed1ce85bb5190d" title="Indicate at runtime which hwloc API version was used at build time. ">hwloc_get_api_version()</a></code> came only in 1.1.1. Also do not use the old cpuset API since it was deprecated and superseded by the bitmap API in 1.1, and later removed in 1.5.</p>
<p> 
</div><div class="section" id="faq4">
 </p>
<h1><a class="anchor" id="faq4"></a>
Platform-specific</h1>
<h2><a class="anchor" id="faq_knl_numa"></a>
How do I find the local MCDRAM NUMA node on Intel Knights Landing Xeon Phi?</h2>
<p>Intel Knights Landing Xeon Phi processors introduce a new memory architecture by possibly having two distinct local memories: some normal memory (DDR) and some high-bandwidth on-package memory (MCDRAM). Processors can be configured in various clustering modes to have up to 4 <em>Clusters</em>. Moreover, each <em>Cluster</em> (quarter, half or whole processor) of the processor may have its own local parts of the DDR and of the MCDRAM. This memory and clustering configuration may be probed by looking at MemoryMode and ClusterMode attributes, see <a class="el" href="a00355.html#attributes_info">Custom string infos</a> and doc/examples/get-knl-modes.c in the source directory.</p>
<p>Starting with version 2.0, hwloc properly exposes this memory configuration. DDR and MCDRAM are attached as two memory children of the same parent, DDR first, and MCDRAM second if any. Depending on the KNL configuration, that parent may be a Package, a Cache, or a Group object of type <code>Cluster</code>.</p>
<p>Hence cores may have one or two local NUMA nodes, listed by the core nodeset. An application may allocate local memory from a core by using that nodeset. The operating system will actually allocate from the DDR when possible, or fallback to the MCDRAM.</p>
<p>To allocate specifically on one of these memories, one should walk up the parent pointers until finding an object with some memory children. Looking at these memory children will give the DDR first, then the MCDRAM if any. Their nodeset may then be used for allocating or binding memory buffers.</p>
<p>One may also traverse the list of NUMA nodes until finding some whose cpuset matches the target core or PUs. The MCDRAM NUMA nodes may be identified thanks to the <code>subtype</code> field which is set to <code>MCDRAM</code>.</p>
<p>Command-line tools such as <code>hwloc-bind</code> may bind memory on the MCDRAM by using the <em>hbm</em> keyword. For instance, to bind on the first MCDRAM NUMA node:</p>
<pre class="fragment">$ hwloc-bind --membind --hbm numa:0 -- myprogram
$ hwloc-bind --membind numa:0 -- myprogram
</pre><h2><a class="anchor" id="faq_knl_dump"></a>
Why do I need hwloc-dump-hwdata for memory on Intel Knights Landing Xeon Phi?</h2>
<p>Intel Knights Landing Xeon Phi processors may use the on-package memory (MCDRAM) as either memory or a memory-side cache (currently reported as a L3 cache by hwloc). There are also several clustering modes that significantly affect the memory organization (see <a class="el" href="a00362.html#faq_knl_numa">How do I find the local MCDRAM NUMA node on Intel Knights Landing Xeon Phi?</a> for more information about these modes). Details about these are currently only available to privileged users.</p>
<p>The hwloc-dump-hwdata utility may be used to dump this privileged binary information into human-readable and world-accessible files that the hwloc library will later load. The utility should usually run as root once during boot, in order to update dumped information (stored under /var/run/hwloc by default) in case the MCDRAM or clustering configuration changed between reboots.</p>
<p>When SELinux MLS policy is enabled, a specific hwloc policy module may be required so that all users get access to the dumped files (in /var/run/hwloc by default). One may use hwloc policy files from the SELinux Reference Policy at <a href="https://github.com/TresysTechnology/refpolicy-contrib">https://github.com/TresysTechnology/refpolicy-contrib</a> (see also the documentation at <a href="https://github.com/TresysTechnology/refpolicy/wiki/GettingStarted">https://github.com/TresysTechnology/refpolicy/wiki/GettingStarted</a>).</p>
<p>hwloc-dump-hwdata requires <code>dmi-sysfs</code> kernel module loaded.</p>
<p>The utility is currently unneeded on non-KNL platforms.</p>
<p>See <code>HWLOC_DUMPED_HWDATA_DIR</code> in <a class="el" href="a00351.html">Environment Variables</a> for details about the location of dumped files.</p>
<h2><a class="anchor" id="faq_phi"></a>
How do I build for Intel Xeon Phi coprocessor?</h2>
<dl class="section note"><dt>Note</dt><dd>This section does not apply to standalone Intel Knights Landing Xeon Phi.</dd></dl>
<p>Intel Knights Corner Xeon Phi coprocessors usually runs a Linux environment but cross-compiling from the host is required. hwloc uses standard autotools options for cross-compiling. For instance, to build for a <em>Knights Corner (KNC)</em> coprocessor:</p>
<p>If building with <code>icc</code>: </p><pre class="fragment">./configure CC="icc -mmic" --host=x86_64-k1om-linux --build=x86_64-unknown-linux-gnu
</pre><p>If building with the Xeon Phi-specific GCC that comes with the MPSS environment, for instance <code>/usr/linux-k1om-4.7/bin/x86_64-k1om-linux-gcc</code>: </p><pre class="fragment">export PATH=$PATH:/usr/linux-k1om-4.7/bin/
./configure --host=x86_64-k1om-linux --build=x86_64-unknown-linux-gnu
</pre><h2><a class="anchor" id="faq_bgq"></a>
How do I build hwloc for BlueGene/Q?</h2>
<p>IBM BlueGene/Q machines run a standard Linux on the login/frontend nodes and a custom CNK (<em>Compute Node Kernel</em>) on the compute nodes.</p>
<p>To discover the topology of a login/frontend node, hwloc should be configured as usual, without any BlueGene/Q-specific option.</p>
<p>However, one would likely rather discover the topology of the compute nodes where parallel jobs are actually running. If so, hwloc must be cross-compiled with the following configuration line: </p><pre class="fragment">./configure --host=powerpc64-bgq-linux --disable-shared --enable-static \
  CPPFLAGS='-I/bgsys/drivers/ppcfloor -I/bgsys/drivers/ppcfloor/spi/include/kernel/cnk/'
</pre><p>CPPFLAGS may have to be updated if your platform headers are installed in a different directory.</p>
<h2><a class="anchor" id="faq_windows"></a>
How do I build hwloc for Windows?</h2>
<p>hwloc releases are available as pre-built ZIPs for Windows on both 32bits and 64bits x86 platforms. They are built using MSYS2 and MinGW on a Windows host. Such an environment allows using the Unix-like <code>configure</code>, <code>make</code> and <code>make install</code> steps without having to tweak too many variables or options. One may look at <code>contrib/ci.inria.fr/job-3-mingw.sh</code> in the hwloc repository for an example used for nightly testing.</p>
<p>hwloc releases also contain a basic Microsoft Visual Studio solution under <code>contrib/windows/</code>.</p>
<h2><a class="anchor" id="faq_netbsd_bind"></a>
How to get useful topology information on NetBSD?</h2>
<p>The NetBSD (and FreeBSD) backend uses x86-specific topology discovery (through the x86 component). This implementation requires CPU binding so as to query topology information from each individual logical processor. This means that hwloc cannot find any useful topology information unless user-level process binding is allowed by the NetBSD kernel. The <code>security.models.extensions.user_set_cpu_affinity</code> sysctl variable must be set to 1 to do so. Otherwise, only the number of logical processors will be detected. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
